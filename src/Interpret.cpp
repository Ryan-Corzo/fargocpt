#include <cctype>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <string>

#include "Interpret.h"
#include "LowTasks.h"
#include "config.h"
#include "constants.h"
#include "global.h"
#include "logging.h"
#include "parameters.h"
#include "start_mode.h"
#include "units.h"

extern int damping_energy_id;
extern std::vector<parameters::t_DampingType> damping_vector;

// frame
int Corotating, GuidingCenter;

int FastTransport;
int OuterSourceMass;

#include <algorithm>
#include <array>
#include <experimental/filesystem>
#include <fstream>
#include <iostream>
#include <memory>
#include <sstream>
#include <stdexcept>
#include <string>
namespace fs = std::experimental::filesystem;

#include "options.h"
#include <sys/stat.h>

// used for calling python script needed for getting the polytropic constants
std::string exec(const char *cmd)
{
    std::array<char, 128> buffer;
    std::string result;
    std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(cmd, "r"), pclose);
    if (!pipe) {
	throw std::runtime_error("popen() failed!");
    }
    while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr) {
	result += buffer.data();
    }
    return result;
}

void get_polytropic_constants(char *filename, double &K, double &gamma)
{
    char command[1024];
    strcpy(command, "python Tools/get_polytropic_constants.py ");
    strcat(command, filename);
    strcat(command, " 0");
    // Python script fits the parameters ADIABATICINDEX and POLYTROPIC_CONSTANT,
    //      so that the pressure is equal to the pressure generated by the
    //      isothermal equation of state.
    std::string polytropic_string = exec(command);
    std::stringstream ss(polytropic_string);

    ss >> K;
    ss >> gamma;
}

static char lowercase_first_letter(const std::string &s)
{
    return tolower(s[0]);
}

std::string launch_cmd(int argc, char **argv)
{
    std::string cmd = "";
    for (int i = 0; i < argc; i++) {
	cmd += argv[i];
	if (i < argc - 1) {
	    cmd += " ";
	}
    }
    return cmd;
}

void write_config_copy_info(const fs::path &file_path,
			    const fs::path &copy_path, std::string cmd)
{
    std::ofstream out_file(file_path);

    out_file << "{" << std::endl;
    out_file << "\"launch options\" : \"";
    out_file << cmd;
    out_file << "\"," << std::endl;
    out_file << "\"config file\": " << copy_path << std::endl;
    out_file << "}" << std::endl;
    out_file.close();
}

void copy_config_file(const char *filename, int argc, char **argv)
{
    if (CPU_Master) {
	// copy setup files into the output folder

	fs::path startlog_dir = fs::path(OUTPUTDIR) / "startlog";
	if (!fs::exists(startlog_dir)) {
	    fs::create_directory(startlog_dir);
	}

	fs::path config_file(filename);
	fs::path config_copy_path =
	    startlog_dir / config_file.filename().stem();

	if (start_mode::mode == start_mode::mode_restart) {
	    config_copy_path += "_restart_";
	    config_copy_path += std::to_string(start_mode::restart_from);
	}
	fs::path config_info_path(config_copy_path);
	config_info_path += "_info.json";
	config_copy_path += config_file.extension();

	std::string cmd = launch_cmd(argc, argv);
	write_config_copy_info(config_info_path, config_copy_path, cmd);

	fs::remove(config_copy_path);
	fs::copy_file(config_file, config_copy_path);
    }

    MPI_Barrier(MPI_COMM_WORLD);
}

void create_outputdir(const char *filename)
{
    fs::path config_file_name(filename);
    OUTPUTDIR = config.get<std::string>("OUTPUTDIR", config_file_name.stem());

    // Create output directory if it doesn't exist
    if (CPU_Master) {
	if (!fs::exists(OUTPUTDIR)) {
	    fs::create_directory(OUTPUTDIR);
	}
    }
    MPI_Barrier(MPI_COMM_WORLD);
}

void interpret_disk_parameters()
{
    MASSTAPER = config.get("MASSTAPER", 0.0000001);
    ROCHESMOOTHING = config.get("ROCHESMOOTHING", 0.0);
    SIGMASLOPE = config.get("SIGMASLOPE", 0.0);
    IMPOSEDDISKDRIFT = config.get("IMPOSEDDISKDRIFT", 0.0);

    FLARINGINDEX = config.get("FLARINGINDEX", 0.0);
    ASPECTRATIO_REF = config.get("ASPECTRATIO", 0.05);
}

void interpret_transport_algo()
{
    switch (tolower(config.get<std::string>("TRANSPORT", "Fast")[0])) {
    case 'f':
	FastTransport = 1;
	break;
    case 's':
	FastTransport = 0;
	break;
    default:
	die("Invalid setting for Transport");
    }
}

void interpret_output_timesteps()
{
    NTOT = config.get("NTOT", 1000);
    NINTERM = config.get("NINTERM", 10);
    DT = config.get("DT", 1.0);
}

void interpret_grid()
{
    if ((parameters::radial_grid_type == parameters::logarithmic_spacing) ||
	(parameters::radial_grid_type == parameters::exponential_spacing)) {
	double c = log(RMAX / RMIN);
	double optimal_N_azimuthal =
	    M_PI / ((exp(c / NRadial) - 1.0) / (exp(c / NRadial) + 1.0));

	// check if optimal azimuthal cell number differs from actual azimuthal
	// cell number by more than 10%
	if (fabs(((double)NAzimuthal - optimal_N_azimuthal) /
		 (double)NAzimuthal) > 0.1) {
	    logging::warning_master(
		"You have %u cells in azimuthal direction. This should be %u cells to have quadratic cells!\n",
		NAzimuthal, lround(optimal_N_azimuthal));
	}
    }
}

void interpret_rotating_frame()
{
    // Frame settings
    Corotating = 0;
    GuidingCenter = 0;
    switch (tolower(config.get<std::string>("Frame", "Fixed")[0])) {
    case 'f': // Fixed
	break;
    case 'c': // Corotating
	Corotating = 1;
	break;
    case 'g': // Guiding-Center
	Corotating = 1;
	GuidingCenter = 1;
	break;
    default:
	die("Invalid setting for Frame");
    }
    OMEGAFRAME = config.get("OMEGAFRAME", double(0));
}

void interpret_coordinate_system_center()
{
    // Barycenter mode
    switch (lowercase_first_letter(
	config.get<std::string>("HydroFrameCenter", "primary"))) {
    case 'p': // primarys
	parameters::n_bodies_for_hydroframe_center = 1;
	break;
    case 'b': // binary
	parameters::n_bodies_for_hydroframe_center = 2;
	break;
    case 't': // tertiary
	parameters::n_bodies_for_hydroframe_center = 3;
	break;
    case 'q': // quaternary
	parameters::n_bodies_for_hydroframe_center = 4;
	break;
    case 'a': // all
	parameters::n_bodies_for_hydroframe_center = 0;
	// will be set to number of bodies when loading planet system
	break;
    default:
	die("Invalid setting for HydroFrameCenter: %s",
	    config.get<std::string>("HydroFrameCenter", "primary").c_str());
    }
}

void interpret_coorindate_system()
{
    interpret_rotating_frame();
    interpret_coordinate_system_center();
}

void warn_about_indirect_term_flag()
{
    if (config.contains("IndirectTerm")) {
	die("Indirect terms are now handled automatically to avoid unphysical settings.",
	    "Please remove the setting.");
    }

    if (config.contains("IndirectTermPlanet")) {
	die("Indirect terms are now handled automatically to avoid unphysical settings.",
	    "Please remove the setting.");
    }
}

void remove_energy_damping_if_unused()
{
    if (!parameters::Adiabatic) // if energy is not needed, delete the energy
				// damping boundary conditions
    {
	parameters::damping_vector.erase(parameters::damping_vector.begin() +
					 parameters::damping_energy_id);
    }

    // delete unneeded calls to damping functions
    // this must be performed after deleting the energy damping boundary,
    // otherwise damping_energy_id would be incorrect.
    auto delete_damping_condition =
	[&](const parameters::t_DampingType damper) {
	    return damper.inner_damping_function == nullptr &&
			   damper.outer_damping_function == nullptr
		       ? true
		       : false;
	};
    parameters::damping_vector.erase(
	std::remove_if(parameters::damping_vector.begin(),
		       parameters::damping_vector.end(),
		       delete_damping_condition),
	parameters::damping_vector.end());
}


void interpret_equation_of_state(char *filename)
{
    // Energy equation / Adiabatic
    char Adiabatic_deprecated =
	lowercase_first_letter(config.get<std::string>("Adiabatic", "false"));

    if (Adiabatic_deprecated == 'n') {
	logging::info_master("Warning : Setting the isothermal equation of state with the flag 'Adiabatic   NO' is deprecated. Use 'EquationOfState   Isothermal' instead.\n");
    }
    if (Adiabatic_deprecated == 'y') {
	parameters::Adiabatic = true;
	logging::info_master("Warning : Setting the ideal equation of state with the flag 'Adiabatic    YES' is deprecated. Use 'EquationOfState   Adiabatic' instead.\n");

	ADIABATICINDEX = config.get("AdiabaticIndex", 7.0 / 5.0);
	if ((parameters::Adiabatic) && (ADIABATICINDEX == 1)) {
	    logging::warning_master(
		"You cannot have Adiabatic=true and AdiabatcIndex = 1. I decided to put Adiabatic=false, to  simulate a locally isothermal equation of state. Please check that it what you really wanted to do!\n");
	    parameters::Adiabatic = false;
	}
    } else {

	const std::string eos_string_tmp =
	    lowercase(config.get<std::string>("EquationOfState", "Isothermal"));
	const char *eos_string = eos_string_tmp.c_str();

	bool could_read_eos = false;
	if (strcmp(eos_string, "isothermal") == 0 ||
	    strcmp(eos_string, "iso") == 0) {
	    could_read_eos = true;
	    parameters::Adiabatic = false;
	    parameters::Polytropic = false;
	    parameters::Locally_Isothermal = true;
	    logging::info_master("Using isothermal equation of state.\n");
	}
	if (strcmp(eos_string, "adiabatic") == 0 ||
	    strcmp(eos_string, "ideal") == 0) {
	    could_read_eos = true;

	    // Energy equation / Adiabatic
	    parameters::Adiabatic = true;

	    const std::string ADIABATICINDEX_string_tmp =
		lowercase(config.get<std::string>("AdiabaticIndex", "7/5"));
	    const char *ADIABATICINDEX_string =
		ADIABATICINDEX_string_tmp.c_str();

	    if (strcmp(ADIABATICINDEX_string, "fit_isothermal") == 0 ||
		strcmp(ADIABATICINDEX_string, "fit isothermal") == 0) {
		logging::error_master(
		    "Automatic AdiabatcIndex determination only available for polytropic equation of state\n");
		PersonalExit(1);
	    } else {
		ADIABATICINDEX = config.get("AdiabaticIndex", 7.0 / 5.0);
	    }

	    if ((parameters::Adiabatic) && (ADIABATICINDEX == 1)) {
		logging::warning_master(
		    "You cannot have Adiabatic=true and AdiabatcIndex = 1. I decided to put Adiabatic=false, to simulate a locally isothermal equation of state. Please check that it what you really wanted to do!\n");
		parameters::Adiabatic = false;
	    }
	    logging::info_master("Using ideal equation of state.\n");
	}

	if (strcmp(eos_string, "polytropic") == 0 ||
	    strcmp(eos_string, "polytrop") == 0 ||
	    strcmp(eos_string, "poly") == 0) {
	    could_read_eos = true;

	    // Equation of state / Polytropic
	    parameters::Polytropic = true;
	    double K = 0.0;
	    double gamma = 0.0;

	    const std::string ADIABATICINDEX_string_tmp =
		lowercase(config.get<std::string>("AdiabaticIndex", "2.0"));
	    const char *ADIABATICINDEX_string =
		ADIABATICINDEX_string_tmp.c_str();

	    if (strcmp(ADIABATICINDEX_string, "fit_isothermal") == 0 ||
		strcmp(ADIABATICINDEX_string, "fit isothermal") == 0) {
		get_polytropic_constants(filename, K, gamma);
		ADIABATICINDEX = gamma;
	    } else {
		ADIABATICINDEX = config.get("AdiabaticIndex", 2.0);
	    }

	    const std::string POLYTROPIC_CONSTANT_string_tmp =
		lowercase(config.get<std::string>("AdiabaticIndex", "7/5"));
	    const char *POLYTROPIC_CONSTANT_string =
		POLYTROPIC_CONSTANT_string_tmp.c_str();

	    if (strcmp(POLYTROPIC_CONSTANT_string, "fit_isothermal") == 0 ||
		strcmp(POLYTROPIC_CONSTANT_string, "fit isothermal") == 0) {
		if (K == 0.0) // Call script only if needed
		{
		    get_polytropic_constants(filename, K, gamma);
		}
		POLYTROPIC_CONSTANT = K;
	    } else {
		POLYTROPIC_CONSTANT = config.get("PolytropicConstant", 12.753);
	    }

	    if ((parameters::Polytropic) && (ADIABATICINDEX == 1)) {
		logging::warning_master(
		    "You cannot have Polytropic=true and AdiabatcIndex = 1. I decided to put Polytropic=false, to simulate a locally isothermal equation of state. Please check that it what you really wanted to do!\n");
		parameters::Polytropic = false;
	    }
	    logging::info_master("Using polytropic equation of state.\n");
	}

	if (!could_read_eos) {
	    const std::string eos_str = config.get("EquationOfState");
	    die("Invalid setting for Energy Equation:   %s\n", eos_str.c_str());
	}
    }

    remove_energy_damping_if_unused();
}


void interpret_Nbody_smoothing() {
	if ((parameters::thickness_smoothing != 0.0) && (ROCHESMOOTHING != 0.0)) {
	logging::error_master( "You cannot use at the same time\n");
	logging::error_master(
			      "`ThicknessSmoothing' and `RocheSmoothing'.\n");
	logging::error_master(
			      "Edit the parameter file so as to remove\n");
	logging::error_master(
			      "one of these variables and run again.\n");
	PersonalExit(1);
    }

    if ((parameters::thickness_smoothing <= 0.0) && (ROCHESMOOTHING <= 0.0)) {
	logging::error_master(
	    "A non-vanishing potential smoothing length is required.\n");
	logging::error_master( "Please use either of the following variables:\n");
	logging::error_master(
			      "`ThicknessSmoothing' *or* `RocheSmoothing'.\n");
	logging::error_master( "before launching the run again.\n");
	PersonalExit(1);
    }

    if (ROCHESMOOTHING != 0.0) {
	RocheSmoothing = YES;
	logging::info_master("Planet potential smoothing scales with their Hill sphere.\n");
    } else if (config.get_flag("ThicknessSmoothingAtPlanet", false)) {
	ThicknessSmoothingAtCell = NO;
	ThicknessSmoothingAtPlanet = YES;
	logging::info_master("Planet potential smoothing uses disk scale height at planet location (bad choice!).\n");
    } else {
	ThicknessSmoothingAtCell = YES;
	ThicknessSmoothingAtPlanet = NO;
	logging::info_master("Planet potential smoothing uses disk scale height at gas cell location.\n");
    }
}

void interpret_Nbody_interactions()
{
    ExcludeHill = config.get_flag("EXCLUDEHILL", false);
	interpret_Nbody_smoothing();
}

void interpret_viscosity()
{
    VISCOSITY = config.get("VISCOSITY", 0.0);
    ALPHAVISCOSITY = config.get("ALPHAVISCOSITY", 0.0);

    if ((ALPHAVISCOSITY != 0.0) && (VISCOSITY != 0.0)) {
	logging::error_master( "You cannot use at the same time\n");
	logging::error_master( "VISCOSITY and ALPHAVISCOSITY.\n");
	logging::error_master(
			      "Edit the parameter file so as to remove\n");
	logging::error_master(
			      "one of these variables and run again.\n");
	PersonalExit(1);
    }

    if (ALPHAVISCOSITY != 0.0) {
	ViscosityAlpha = YES;
	logging::info_master("Viscosity is of alpha type\n");
    }
}

void sanitize_output_dir_string() {
    // Add a trailing slash to OUTPUTDIR if needed
    if (OUTPUTDIR[OUTPUTDIR.length() - 1] != '/') {
	OUTPUTDIR.append("/");
    }
}

void interpret_boundary() {
	// perscriped mass accretion through outer boundary
	OuterSourceMass = config.get_flag("OUTERSOURCEMASS", false);
}

void ReadVariables(char *filename, t_data &data, int argc, char **argv)
{
    parameters::read(filename, data);

    interpret_disk_parameters();

    create_outputdir(filename);

    start_mode::configure_start_mode();

    copy_config_file(filename, argc, argv);

    interpret_transport_algo();

    interpret_output_timesteps();

    interpret_grid();

    interpret_coorindate_system();

    warn_about_indirect_term_flag();

    interpret_equation_of_state(filename);

    interpret_Nbody_interactions();

    interpret_viscosity();

	interpret_boundary();

	sanitize_output_dir_string();
    
    constants::initialize_constants();

    // now we now everything to compute unit factors
    units::calculate_unit_factors();

    // TODO: This should definitely done in parameters.cpp, where values are
    // read, but parameters::read() is called before
    // units::calculate_unit_factors() so it is not possible. Moving the read()
    // call causes an error.
    parameters::apply_units();

	double foo = parameters::maximum_temperature * units::temperature.get_inverse_cgs_factor();
	std::cout << "!!!!!!!!!!!!!!!!!!!! double max = " << std::numeric_limits<double>::max() << std::endl;
	std::cout << "!!!!!!!!!!!!!!!!!!!! maximum T = " << foo << std::endl;
	std::cout << "!!!!!!!!!!!!!!!!!!!! 1.1*double max = " << 1.1*std::numeric_limits<double>::max() << std::endl;
	std::cout << "!!!!!!!!!!!!!!!!!!!! 2 < 1.1*double max = " << (-100 < 1.1*std::numeric_limits<double>::max()) << std::endl;
}

void PrintUsage(char *execname)
{
    logging::error_master(
	"Usage : %s [-abcdeimnptvz] [-(0-9)] [-s number] [-f scaling] parameters file\n",
	execname);
    logging::error_master(
	"\n-a : Monitor mass and angular momentum at each timestep\n");
    logging::error_master(
	"-b : Adjust azimuthal velocity to impose strict centrifugal balance at t=0\n");
    logging::error_master(
	"-c : Sloppy CFL condition (checked at each DT, not at each timestep)\n");
    logging::error_master(
	"-d : Print some debugging information on 'stdout' at each timestep\n");
    logging::error_master(
			  "-e : Activate EU test problem torque file output\n");
    logging::error_master(
	"-f : Scale density array by 'scaling'. Useful to increase/decrease\n");
    logging::error_master(
	"     disk surface density after a restart, for instance.            \n");
    logging::error_master( "-i : tabulate Sigma profile as given by restart files\n");
    logging::error_master(
	"-n : Disable simulation. The program just reads parameters file\n");
    logging::error_master(
			  "-o : Overrides output directory of input file.\n");
    logging::error_master( "-p : Give profiling information at each time step\n");
    logging::error_master(
	"-s : Restart simulation, taking #'number' files as initial conditions\n");
    logging::error_master(
	"-v : Verbose mode. Tells everything about parameters file\n");
    logging::error_master(
	"-z : fake sequential built when evaluating sums on HD meshes\n");
    logging::error_master( "-(0-9) : only write initial (or restart) HD meshes,\n");
    logging::error_master(
			  "     proceed to the next nth output and exit\n");
    logging::error_master(
	"     This option must stand alone on one switch (-va -4 is legal, -v4a is not)\n");
    PersonalExit(1);
}

double TellNbOrbits(double time)
{
    return time / 2.0 / PI * sqrt(constants::G * 1.0 / 1.0 / 1.0 / 1.0);
}

double TellNbOutputs(double time) { return (time / DT / NINTERM); }

void TellEverything()
{
    double temp;

    if (!CPU_Master)
	return;

    logging::verbose_master("Disc properties:\n");
    logging::verbose_master("----------------\n");
    logging::verbose_master("Inner Radius          : %g\n", RMIN);
    logging::verbose_master("Outer Radius          : %g\n", RMAX);
    logging::verbose_master("Aspect Ratio          : %g\n",
			  ASPECTRATIO_REF);
    logging::verbose_master("VKep at inner edge    : %.3g\n",
			  sqrt(constants::G * 1.0 * (1. - 0.0) / RMIN));
    logging::verbose_master("VKep at outer edge    : %.3g\n",
			  sqrt(constants::G * 1.0 / RMAX));
    /*
    logging::verbose_master("boundary_inner        : %i\n",
    parameters::boundary_inner); logging::verbose_master("boundary_outer        : %i\n", parameters::boundary_outer);
    */
    // temp=2.0*PI*parameters::sigma0/(2.0-SIGMASLOPE)*(pow(RMAX,2.0-SIGMASLOPE)
    // - pow(RMIN,2.0-SIGMASLOPE));	/* correct this and what follows... */
    // logging::verbose_master("Initial Disk Mass             :
    // %g\n", temp); temp=2.0*PI*parameters::sigma0/(2.0-SIGMASLOPE)*(1.0 -
    // pow(RMIN,2.0-SIGMASLOPE)); logging::verbose_master("Initial
    // Mass inner to r=1.0  : %g \n", temp);
    // temp=2.0*PI*parameters::sigma0/(2.0-SIGMASLOPE)*(pow(RMAX,2.0-SIGMASLOPE)
    // - 1.0); logging::verbose_master("Initial Mass outer to r=1.0 :
    // %g \n", temp);
    logging::verbose_master("Travelling time for acoustic density waves :\n");
    temp = 2.0 / 3.0 / ASPECTRATIO_REF * (pow(RMAX, 1.5) - pow(RMIN, 1.5));
    logging::verbose_master(" * From Rmin to Rmax  : %.2g = %.2f orbits ~ %.1f outputs\n", temp,
	TellNbOrbits(temp), TellNbOutputs(temp));
    temp = 2.0 / 3.0 / ASPECTRATIO_REF * (pow(RMAX, 1.5) - pow(1.0, 1.5));
    logging::verbose_master(" * From r=1.0 to Rmax: %.2g = %.2f orbits ~ %.1f outputs\n", temp,
	TellNbOrbits(temp), TellNbOutputs(temp));
    temp = 2.0 / 3.0 / ASPECTRATIO_REF * (pow(1.0, 1.5) - pow(RMIN, 1.5));
    logging::verbose_master(" * From r=1.0 to Rmin: %.2g = %.2f orbits ~ %.1f outputs\n", temp,
	TellNbOrbits(temp), TellNbOutputs(temp));
    temp = 2.0 * PI * sqrt(RMIN * RMIN * RMIN / constants::G / 1.0);
    logging::verbose_master("Orbital time at Rmin  : %.3g ~ %.2f outputs\n", temp,
			  TellNbOutputs(temp));
    temp = 2.0 * PI * sqrt(RMAX * RMAX * RMAX / constants::G / 1.0);
    logging::verbose_master("Orbital time at Rmax  : %.3g ~ %.2f outputs\n", temp,
			  TellNbOutputs(temp));
    logging::verbose_master("Sound speed :\n");
    logging::verbose_master(" * At unit radius     : %.3g\n",
			  ASPECTRATIO_REF * sqrt(constants::G * 1.0));
    logging::verbose_master(" * At outer edge      : %.3g\n",
			  ASPECTRATIO_REF * sqrt(constants::G * 1.0 / RMAX));
    logging::verbose_master(" * At inner edge      : %.3g\n",
			  ASPECTRATIO_REF * sqrt(constants::G * 1.0 / RMIN));
    logging::verbose_master("Grid properties:\n");
    logging::verbose_master("----------------\n");
    logging::verbose_master("Number of (local) rings  : %d\n",
			  NRadial);
    logging::verbose_master("Number of (global) rings : %d\n",
			  GlobalNRadial);
    logging::verbose_master("Number of sectors        : %d\n",
			  NAzimuthal);
    logging::verbose_master("Total (local) cells      : %d\n",
			  NRadial * NAzimuthal);
    logging::verbose_master("Total (gobal) cells      : %d\n",
			  GlobalNRadial * NAzimuthal);
    logging::verbose_master("Outputs properties:\n");
    logging::verbose_master("-------------------\n");
    logging::verbose_master("Time increment between outputs : %.3f = %.3f orbits\n",
	NINTERM * DT, TellNbOrbits(NINTERM * DT));
}
